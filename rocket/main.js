let wrapper = document.getElementById('wrap-sim');
let canvas = document.getElementById('sim');
let ctx = canvas.getContext("2d");
let height, width;
let omega = 0;
let getDisplayName = (r) => "";
let shakeAxis;
let nxref = 1;
let nxstep = 0;


var workerCalcCLP = {};
const vlist = ['y', 'th', 'x'];

const REFCURSOR = Object.freeze({
    X: [1, 0],
    Y: [0, 1],
    XY: [1, 1]
});

let refcursor = REFCURSOR.XY;

var keyPressed = {};
document.onkeyup = function (e) {
    keyPressed[e.keyCode] = false;
}
document.onkeydown = function (e) {
    keyPressed[e.keyCode] = true;
}

let design = {
    params: 'g = 9.8\nL = 3; W = 0.3; l = L/2\nm = 1; I = 1/3 m*l^2',
    controllers: {
        y: '2(1+0.5s)/(1+0.5s/10)',
        th: '-10(1+1s)/(1+10s/20)',
        x: '0.001(1+10s)/(1+10s/30)'
    },
    ui: {}
};

savedUI = ['chk-iniVelX', 'chk-iniVelY', 'chk-center-r', 'chk-iniVelTh', 'field-maxacc'];

let editorCache = {
    K: {},
    tfL: {}
};

$('.latex').each((idx, e) => {
    katex.render(e.textContent, e);
});

$('#myTab a').on('click', function (e) {
    e.preventDefault()
    $(this).tab('show')
})

function decode(string) {
    return RawDeflate.inflate(window.atob(string));
}

function encode(string) {
    return window.btoa(RawDeflate.deflate(string));
}

function load_design(d) {
    design = d;
    $('#field-consts').val(design.params);
    $.each(design.controllers, (key, val) => {
        $('#field-K' + key).val(val);
    })
    $.each(design.ui, (key, val) => {
        if (key.startsWith('chk-')) {
            $('#' + key).prop('checked', val);
        } else {
            $('#' + key).val(val);
        }
    });
}

if (window.location.hash) {
    var hash = window.location.hash.substr(4);
    var version = window.location.hash.substr(2, 2);
    if (version !== '1/') {
        alert(':shared link is generated by unknown version' + version);
    } else {
        load_design(JSON.parse(decode(hash)));
    }
} else {
    load_design(design);
}

$('#save-dialog').on('shown.bs.modal', function () {
    design.ui = {};
    savedUI.forEach((e) => {
        if (e.startsWith('chk-')) {
            design.ui[e] = $('#' + e).prop('checked');
        } else {
            design.ui[e] = $('#' + e).val();
        }
    });
    let url = (location.origin === "null" ? 'file://' : location.origin) + location.pathname + '#/1/' + encode(JSON.stringify(design));

    $('#save-url').val(url);
    $('#save-url').trigger('focus');
    $('#save-url').trigger('select');

});

$('#copy-url').on('click', function () {
    $('#save-url').trigger('focus');
    $('#save-url').trigger('select');
    document.execCommand('copy');
});



let updateBode = {
    'y': function () {
        drawBode(editorCache.tfL.y.compile(), logspace(-2, 2, 100), 'wrap-canvas-Ky', 'canvas-Ky');
    },
    'th': function () {
        drawBode(editorCache.tfL.th.compile(), logspace(-2, 2, 100), 'wrap-canvas-Kth', 'canvas-Kth');
    },
    'x': function () {
        drawBode(editorCache.tfL.x.compile(), logspace(-2, 2, 100), 'wrap-canvas-Kx', 'canvas-Kx');
    }
};

let workerJobs = {};

function startWorkerCLP(v) {
    workerCalcCLP[v] = new Worker("worker_calcCLP.js");
    workerJobs[v] = 0;
    workerCalcCLP[v].onmessage = function (e) {
        workerJobs[v]--;
        if (workerJobs[v] == 0) {
            updateCLP(v, e.data[0]);
        }
    }
}


vlist.forEach(
    (v) => {
        $(`#K${v}-tab`).on("shown.bs.tab", updateBode[v]);
        startWorkerCLP(v);
    }
);


let show_info = 0;


let rx = 0,
    rvx = 0,
    rrx = 0;
let ry = 0,
    rvy = 0,
    rry = 0;

let K = {};

function updateCLP(v, roots) {
    let p = root2math(roots);
    let npols = p.length,
        clpols = '',
        firstPole = true;

    for (let i = 0; i < npols; i++) {
        let isStable = true;
        if (p[i].re > 0) {
            isStable = false;
            clpols += '{\\color{red}';
        }
        if (math.abs(p[i].re / p[i].im) < 1e-2) {
            // pure imaginary pole
            if (i < npols - 1 && math.abs(math.add(p[i], p[i + 1])) < 1e-10) {
                clpols += '\\pm' + num2tex(Math.abs(p[i].im), 2) + 'j';
                i++;
            } else {
                clpols += num2tex(p[i].im, 2) + 'j';
            }
        } else if (math.abs(p[i].im / p[i].re) < 1e-2) {
            // real pole
            clpols += num2tex(p[i].re, 2);
        } else {
            if (i < npols - 1 && math.equal(p[i], math.conj(p[i + 1]))) {
                clpols += num2tex(p[i].re, 2) + '\\pm ' +
                    num2tex(Math.abs(p[i].im), 2) + 'j';
                i++;
            } else {
                clpols += num2tex(p[i].re, 2) + (p[i].im > 0 ? '+' : '') +
                    num2tex(p[i].im, 2) + 'j';
            }
        }
        if (!isStable) {
            clpols += '}';
        }
        if (i < npols - 1) {
            clpols += ', ';
        }
    }

    katex.render(
        clpols,
        document.getElementById('clp-' + v), {
            displayMode: true
        }
    );
    $('#clp-' + v).removeClass('now-calc')
}


function updateController(design, toEditor = true) {
    let ret = {
        K: {},
        tfL: {}
    };
    let vars = {};
    let tfP = {};

    if (toEditor) {
        load_design(design);
        draw_info();
    }
    math.eval(design.params, vars);

    for (var key in vars) {
        if (vars.hasOwnProperty(key)) {
            vars[key] = new math.expression.node.ConstantNode(vars[key]);
        }
    }

    vlist.forEach((v) => {
        let eq;
        let Peq;
        if (toEditor) {
            try {
                Peq = math.parse($('#field-P' + v).val());
                tfP[v] = subs(Peq, vars);
                $('#field-P' + v).removeClass('is-invalid').addClass('is-valid');
                $('#vf-P' + v).removeClass('invalid-feedback').addClass('valid-feedback');
                $('#vf-P' + v).text('');
            } catch (e) {
                $('#field-P' + v).removeClass('is-valid').addClass('is-invalid');
                $('#vf-P' + v).removeClass('valid-feedback').addClass('invalid-feedback');
                $('#vf-P' + v).text(e.toString());
                return;
            }
            vars['P' + v] = tfP[v];
            try {
                eq = math.parse(design.controllers[v]);
                editorCache.tfL[v] = new math.expression.node.OperatorNode('*', 'multiply', [eq, tfP[v]]);
                updateBode[v]();
                $('#field-K' + v).removeClass('is-invalid').addClass('is-valid');
                $('#vf-K' + v).removeClass('invalid-feedback').addClass('valid-feedback');
                $('#vf-K' + v).text('');
            } catch (e) {
                $('#field-K' + v).removeClass('is-valid').addClass('is-invalid');
                $('#vf-K' + v).removeClass('valid-feedback').addClass('invalid-feedback');
                $('#vf-K' + v).text(e.toString());
                return;
            }
            vars['K' + v] = eq;
        } else {
            eq = math.parse(design.controllers[v]);
        }
        var Krat = util_rationalize(eq);

        if (toEditor) {
            if (v == 'th') {
                var Prat = util_rationalize(tfP[v]);
                vars['SthKth'] = new math.expression.node.OperatorNode('/', 'divide', [
                    new math.expression.node.OperatorNode('*', 'multiply', [Prat.denominator, Krat.numerator]),
                    new math.expression.node.OperatorNode('+', 'add', [
                        new math.expression.node.OperatorNode('*', 'multiply', [Prat.denominator, Krat.denominator]),
                        new math.expression.node.OperatorNode('*', 'multiply', [Prat.numerator, Krat.numerator])
                    ])
                ])
            }

            $('#clp-' + v).text('(now calculating...)').addClass('now-calc');
            if (workerJobs[v] > 0) {
                workerCalcCLP[v].terminate();
                startWorkerCLP(v);
            }
            workerJobs[v]++;
            workerCalcCLP[v].postMessage([JSON.stringify(eq), JSON.stringify(tfP[v])]);

            katex.render(
                `${eq.toTex().replace(/SthKth/g,'\\frac{K_\{\\theta\}(s)}{1+P_\{\\theta\}(s)K_\{\\theta\}(s)}')}`,
                document.getElementById('eq-K' + v), {
                    displayMode: true
                }
            );
            katex.render(
                `${Peq.toTex().replace(/SthKth/g,'\\frac{K_\{\\theta\}(s)}{1+P_\{\\theta\}(s)K_\{\\theta\}(s)}')}`,
                document.getElementById('eq-P' + v), {
                    displayMode: true
                }
            );
        }


        let den = util_rationalize(Krat.denominator);
        if (toEditor) {
            try {
                ret.K[v] = Ltisys.realizeFromTf(Krat.coefficients, den.coefficients);
                $('#field-K' + v).removeClass('is-invalid').addClass('is-valid');
                $('#vf-K' + v).removeClass('invalid-feedback').addClass('valid-feedback');
                $('#vf-K' + v).text('');
            } catch (e) {
                $('#field-K' + v).removeClass('is-valid').addClass('is-invalid');
                $('#vf-K' + v).removeClass('valid-feedback').addClass('invalid-feedback');
                $('#vf-K' + v).text(e.toString());
                return;
            }
        } else {
            ret.K[v] = Ltisys.realizeFromTf(Krat.coefficients, den.coefficients);
        }

    });
    if (toEditor) {
        $('#debug').val(JSON.stringify(design));
    }
    return ret;
}

let rockets = [];
let t = 0,
    dt = 1 / 120;

function clear_rockets() {
    rockets = [];
}

function btn_spawn() {
    let dx0 = $('#chk-iniVelX').prop('checked') ? math.random(-5, 5) : 0,
        dy0 = $('#chk-iniVelY').prop('checked') ? math.random(-5, 5) : 0,
        dth0 = $('#chk-iniVelTh').prop('checked') ? math.random(-0.5, 0.5) : 0;
    spawn(design, math.matrix([
        [rx],
        [ry],
        [0],
        [dx0],
        [dy0],
        [dth0]
    ]));
}

let autoref_t0, rax, ray;

function rgen_debug_ramp_y() {
    rx = 0;
    ry = (t - autoref_t0) * rvy;
}

function rgen_debug_ramp_x() {
    ry = 0;
    rx = (t - autoref_t0) * rvx;
}

function rgen_debug_acc_y() {
    rx = 0;
    rvy = (t - autoref_t0) * ray;
    ry = 1 / 2 * (t - autoref_t0) * (t - autoref_t0) * ray;
}

function rgen_debug_acc_x() {
    ry = 0;
    rvx = (t - autoref_t0) * rax;
    rx = 1 / 2 * (t - autoref_t0) * (t - autoref_t0) * rax;
}


function debug_ramp_y(vel) {
    autoref_t0 = t;
    rvy = vel == undefined ? Number($('#field-debug-amount').val()) : vel;
    rgen = rgen_debug_ramp_y;
}

function debug_ramp_x(vel) {
    autoref_t0 = t;
    rvx = vel == undefined ? Number($('#field-debug-amount').val()) : vel;
    rgen = rgen_debug_ramp_x;
}

function debug_accel_y(acc) {
    autoref_t0 = t;
    ray = acc == undefined ? Number($('#field-debug-amount').val()) : acc;
    rgen = rgen_debug_acc_y;
}

function debug_accel_x(acc) {
    autoref_t0 = t;
    rax = acc == undefined ? Number($('#field-debug-amount').val()) : acc;
    rgen = rgen_debug_acc_x;
}

function debug_step(v) {
    d = Object.assign({}, design);
    let rx = 0;
    let ry = 0;
    let out = $('#debug-out');
    let idx = 0;
    let u;
    if (v === 'x') {
        rx = Number($('#field-debug-amount').val());
        u = (r) => r.Fx
    } else {
        idx = 1;
        ry = Number($('#field-debug-amount').val());
        u = (r) => r.Fy
    }
    d.rgen = (t, rx0, ry0) => math.matrix([
        [rx],
        [ry]
    ]);
    out.val(`t\tx\ty\tFx\tFy\n`)
    d.debug = (t, r) => {
        out.val(out.val() + `${t.toFixed(4)}\t${r.x.get([0,0]).toPrecision(5)}\t${r.x.get([1,0]).toPrecision(5)}\t${r.Fx.toPrecision(5)}\t${r.Fy.toPrecision(5)}\n`);
    }
    spawn(d, math.matrix([
        [0],
        [0],
        [0],
        [0],
        [0],
        [0]
    ]));
}

function reset_r(){
    rx = 0;
    rvx = 0;
    rrx = 0;
    ry = 0;
    rvy = 0;
    rry = 0;
    rgen = rgen_manual
}

function debug_mass_spawn_x(list) {
    refcursor = REFCURSOR.X;
    getDisplayName = (r) => r.displayNameX;
    show_info = 0;

    let n = (list == undefined) ? designs.length : list.length;

    let ny = 4;
    let nx = Math.ceil(n/ny);
    nxstep = 5
    nxref = nx
    for (let k = 0; k < n; k++) {
        let idx = (list == undefined) ? k : list[k];
        d = Object.assign({}, designs[idx]);
        let ax = Math.floor((n-k-1)/ny);
        let ay = (n-k-1) % ny;
        let rx = ax*nxstep;
        let ry = (-ay + ny / 2) * 3;
        d.rgen = (t, rx0, ry0) => math.matrix([
            [rx0 + rx],
            [ry]
        ]);
        d.debug = (t, r) => {}
        spawn(d, math.matrix([
            [rx],
            [ry],
            [0],
            [0],
            [0],
            [0]
        ]));
    }
    rx = 0;
    rvx = 0;
    rrx = 0;
    ry = 0;
    rvy = 0;
    rry = 0;
}


function debug_mass_spawn_y(list) {
    refcursor = REFCURSOR.Y;
    getDisplayName = (r) => r.displayNameY;
    let n = (list == undefined) ? designs.length : list.length;
    show_info = 90;
    for (let k = 0; k < n; k++) {
        let idx = (list == undefined) ? k : list[k];
        d = Object.assign({}, designs[idx]);
        let rx = (k - n / 2) * 5;
        let ry = 0;
        d.rgen = (t, rx0, ry0) => math.matrix([
            [rx],
            [ry0]
        ]);
        d.debug = (t, r) => {}
        spawn(d, math.matrix([
            [rx],
            [ry],
            [0],
            [0],
            [0],
            [0]
        ]));
    }
    rx = 0;
    rvx = 0;
    rrx = 0;
    ry = 0;
    rvy = 0;
    rry = 0;
}


let step_log = [], id_table = {}

function mass_step_x(width){
    let t0 = t+10
    omega = 2*Math.PI/10

    rgen = function(){
       if(t-t0 > 0){
           rx = width
       }else{
           rx = 0
       }
    }
    let k = 0
    rockets.forEach(function (r) {
        r.timer_int = -10;
        r.e2 = 0;
        r.timer = r.timer_int;
        r.id = k
        step_log[k] = {
            name:r.pureName,
            ex:[]
        }
        r.debug = (t, r) => {
            r.timer_int += dt
            r.timerStyle = "#e2041b"
            r.e2 += r.ex*r.ex*dt/width/width
            r.timer = r.e2
            /*
            if(r.timer_int <= 0 || Math.abs(r.ex)>0.02*width){
                if(r.timer_int <= -5){
                    r.timer = -5
                }else{
                    r.timer = r.timer_int 
                }
            }else if(r.timer_int >0){
                r.timerStyle = "#3eb370"
            }
            */
            step_log[r.id].ex.push(r.ex)
        }
        k++
    }); 
}

function shake(v){
    let width = Number($('#field-debug-amount').val())
    let t0 = t + 10
    shakeAxis = v
    omega = 2*Math.PI/10
    if (v === 'x') {
        rgen = function(){
            //omega = 0.5
            if(t<t0){
                omega = 0
                rx = 0
                rvx = 0
            }else{
                omega = 0.2+(t-t0)*(t-t0)*8e-5
                rx = width*(1 - Math.cos(omega*(t-t0)))/2
                rvx = width * omega * Math.sin(omega*(t-t0))/2
            }
            // let vel = 2
            // let ph = (t-t0)<5 ?  0 : (t-t0-5)/2/(width/vel) % 1;
            // if(ph<0.5){
            //     rvx = 1
            //     rx = ph*2*width
            // }else{
            //     rvx = -1
            //     rx = (1 - ph)*width*2
            // }
            // rx = width*(1 - Math.sign(Math.cos(omega*(t-t0))))/2
            // rvx = 0
        }        
    } else {
        rgen = function(){
            omega = 0.1+(t-t0)*(t-t0)*8e-5
            ry = width*(1 - Math.cos(omega*(t-t0)))/2
            rvy = width * omega * Math.sin(omega*(t-t0))/2
        }        
    }
}

function spawn(design0, x0) {
    let vars = {};
    let designed = updateController(design0, false);
    math.eval(design0.params, vars);

    let r = new Rocket(
        x0,
        t, {
            y: designed.K.y.clone(),
            th: designed.K.th.clone(),
            x: designed.K.x.clone()
        });


    r.g = toNum(vars.g);
    r.m = toNum(vars.m);
    r.I = toNum(vars.I);
    r.l = toNum(vars.l);
    r.L = toNum(vars.L);
    r.W = toNum(vars.W);
    if (design0.rgen !== undefined) {
        r.rgen = design0.rgen;
    }
    if (design0.debug !== undefined) {
        r.debug = design0.debug;
    }
    r.name = getDisplayName(design0);
    r.pureName = design0.displayName
    rockets.push(r);
}

let vymin = -200,
    vymax = 200,
    vxmin = -200,
    vxmax = 200;
const minvx = 20,
    minvy = 20;
let scale = 1;
let maxAcc = 20;
let center = {
    x: 0,
    y: 0
};

function rgen_manual() {
    let rfx = (rrx - rx),
        rfy = (rry - ry);
    let softsign = (x) => 100 * x / (1 + 100 * Math.abs(x));
    rfx = 2 / dt * (softsign(rfx) * Math.sqrt(0.9 * 2 * maxAcc * math.abs(rfx)) - rvx);
    rfx = clip(rfx, -maxAcc, maxAcc);
    rfy = 2 / dt * (softsign(rfy) * Math.sqrt(0.9 * 2 * maxAcc * math.abs(rfy)) - rvy);
    rfy = clip(rfy, -maxAcc, maxAcc);

    rvx += rfx * dt;
    rvy += rfy * dt;
    rx += rvx * dt;
    ry += rvy * dt;
}
let rgen = rgen_manual;

function loop() {

    if (document.activeElement.type !== "textarea" && document.activeElement.type !== "text") {
        if (keyPressed[37]) center.x -= 10 / scale; // left
        if (keyPressed[38]) center.y += 10 / scale; // Up
        if (keyPressed[39]) center.x += 10 / scale; // right
        if (keyPressed[40]) center.y -= 10 / scale; // down
        if (keyPressed[90]) scale *= 1.02; // z
        if (keyPressed[88]) scale /= 1.02; // x
    }


    if ($('#chk-center-rx').prop('checked')) {
        center.x = rx;
    }
    if ($('#chk-center-ry').prop('checked')) {
        center.y = ry;
    }
    rockets.forEach(function (r) {
        let t0 = t;
        for (let i = 0; i < ((1 / 60) / dt - 0.1); i++) {
            r.step(t0, rx, ry, dt);
            t0 += dt;
        }
    });
    t += 1 / 60;
    rockets = rockets.filter(function (r) {
        let y = r.x.get([1, 0]);
        let x = r.x.get([0, 0]);
        return (!isNaN(x) && !isNaN(y) && Math.abs(r.x.get([2,0]))<100);
    });

    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    ctx.translate(canvas.width / 2, canvas.height / 2);
    ctx.scale(scale * devicePixelRatio, -scale * devicePixelRatio);
    ctx.translate(-center.x, -center.y)
    vxmin = -canvas.width / 2 / devicePixelRatio / scale + center.x;
    vxmax = +canvas.width / 2 / devicePixelRatio / scale + center.x;
    vymin = -canvas.height / 2 / devicePixelRatio / scale + center.y;
    vymax = +canvas.height / 2 / devicePixelRatio / scale + center.y;

    let fontSize = 14 / scale;
    ctx.font = `bold ${fontSize.toFixed(5)}px Arial`;

    function text(s, x, y) {
        ctx.save();
        ctx.translate(x, y);
        ctx.scale(1, -1);
        ctx.fillText(s, 0, 0);
        ctx.restore();
    }

    const gw = 1 * Math.pow(10, -Math.floor(Math.log10(scale / 10)))
    ctx.strokeStyle = "#AAAAFF";
    ctx.lineWidth = 0.5 / scale;
    for (let x = Math.floor(vxmin / gw) * gw; x <= vxmax; x += gw) {
        ctx.lineWidth = ((Math.round(x / gw) % 10 == 0) ? 1.5 : 0.5) / scale;
        ctx.lineWidth = x == 0 ? 2 / scale : ctx.lineWidth;
        ctx.beginPath();
        ctx.moveTo(x, vymin);
        ctx.lineTo(x, vymax);
        ctx.stroke();
    }
    for (let y = Math.floor(vymin / gw) * gw; y <= vymax; y += gw) {
        ctx.lineWidth = ((Math.round(y / gw) % 10 == 0) ? 1.5 : 0.5) / scale;
        ctx.lineWidth = y == 0 ? 2 / scale : ctx.lineWidth;
        ctx.beginPath();
        ctx.moveTo(vxmin, y);
        ctx.lineTo(vxmax, y);
        ctx.stroke();
    }
    ctx.lineWidth = 2 / scale;
    ctx.strokeStyle = "#333333";
    let uni = 10 * gw > canvas.width / 4 / devicePixelRatio / scale ? 1 : 10;
    ctx.beginPath();
    ctx.moveTo(vxmax - 15 / scale, vymax - 85 / scale + 10 / scale);
    ctx.lineTo(vxmax - 15 / scale, vymax - 85 / scale);
    ctx.lineTo(vxmax - 15 / scale - uni * gw, vymax - 85 / scale);
    ctx.lineTo(vxmax - 15 / scale - uni * gw, vymax - 85 / scale + 10 / scale);
    ctx.stroke();
    ctx.fillStyle = "#333333";
    ctx.textBaseline = "alphabetic";
    ctx.textAlign = "right";
    let gwstr = math.unit(gw * uni, 'm').toString();
    text(gwstr, vxmax - 30 / scale - uni * gw, vymax - 85 / scale)


    rgen();

    ctx.strokeStyle = "#FF0000";
    if(refcursor[0]==1 && refcursor[1]==1){
        ctx.lineWidth = 3 / scale;
        ctx.beginPath();
        ctx.moveTo(rrx - 10 / scale, rry - 10 / scale);
        ctx.lineTo(rrx + 10 / scale, rry + 10 / scale);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(rrx - 10 / scale, rry + 10 / scale);
        ctx.lineTo(rrx + 10 / scale, rry - 10 / scale);
        ctx.stroke();    
    }
    ctx.lineWidth = 1 / scale;
    ctx.strokeStyle = "#FF0000";
    if (refcursor[1] == 1) {
        ctx.beginPath();
        ctx.moveTo(vxmin, ry);
        ctx.lineTo(vxmax, ry);
        ctx.stroke();
    }
    if (refcursor[0] == 1) {
        for(let k=0;k<nxref;k++){
            ctx.beginPath();
            ctx.moveTo(rx+nxstep*k, vymin);
            ctx.lineTo(rx+nxstep*k, vymax);
            ctx.stroke();    
        }
    }

    ctx.fillStyle = "#FF0000";
    ctx.textBaseline = "top";
    ctx.font = `bold ${fontSize}px Consolas`;
    ctx.textAlign = "left";
    text(`rx = ${rx.toFixed(2)}`, rx+2/scale, vymax);
    ctx.textBaseline = "bottom";    
    text(`ry = ${ry.toFixed(2)}`, vxmin+2/scale, ry);

    if(shakeAxis == 'x'){
        ctx.textBaseline = "top";
        ctx.font = `bold ${fontSize}px Consolas`;
        ctx.textAlign = "right";
        text(`ω = ${omega.toFixed(2)}`, rx+2/scale, vymax);    
    }

    
    if(shakeAxis == 'y'){
        ctx.textBaseline = "top";
        ctx.font = `bold ${fontSize}px Consolas`;
        ctx.textAlign = "left";
        text(`ω = ${omega.toFixed(2)}`,  vxmin+2/scale, ry);    
    }

    ctx.fillStyle = "#004433";
    ctx.textAlign = "left";

    rockets.forEach(function (r) {
        r.draw(ctx, scale, show_info);
    });
    draw_info();
    window.requestAnimationFrame(loop);
}

let canvasInfo = document.getElementById('canvas-info');
let ctxInfo = canvasInfo.getContext("2d");

function draw_info() {
    let ctx = ctxInfo;
    let th = 0.5;
    let r;
    let vars = {};
    try {
        math.eval($('#field-consts').val(), vars);
    } catch (e) {
        return;
    }

    if (rockets.length == 0) {
        r = new Rocket(math.matrix([
            [0],
            [0],
            [th],
            [0],
            [0],
            [0]
        ]), 0, {});
        r.g = toNum(vars.g);
        r.m = toNum(vars.m);
        r.I = toNum(vars.I);
        r.l = toNum(vars.l);
        r.L = toNum(vars.L);
        r.W = toNum(vars.W);
        r.F = r.m * r.g;
        r.phi = 0;
    } else {
        r = rockets[0];
        th = r.x.get([2, 0]);
    }
    let fx = r.F * Math.sin(r.phi + th);
    let fy = -r.F * Math.cos(r.phi + th);
    let phi = r.phi;


    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.clearRect(0, 0, canvasInfo.width, canvasInfo.height);

    ctx.translate(canvasInfo.width / 2, canvasInfo.height / 2);
    ctx.scale(scale * devicePixelRatio, -scale * devicePixelRatio);
    ctx.translate(-r.x.get([0, 0]), -r.x.get([1, 0]));
    ctx.strokeStyle = "#aaaaaa";
    r.draw(ctx, scale * 2, false);
    ctx.translate(r.x.get([0, 0]), r.x.get([1, 0]));
    ctx.rotate(-th);
    let fontSize = 14 / scale;
    ctx.font = `${fontSize}px Consolas`;
    ctx.fillStyle = "#008888";
    ctx.textBaseline = "middle";

    function text(s, x, y) {
        ctx.save();
        ctx.translate(x, y);
        ctx.scale(1, -1);
        ctx.rotate(-th);
        ctx.fillText(s, 0, 0);
        ctx.restore();
    }

    function line(bx, by, ex, ey) {
        ctx.beginPath();
        ctx.moveTo(bx, by);
        ctx.lineTo(ex, ey);
        ctx.stroke();
    }
    let W = r.W;

    ctx.lineWidth = 1 / scale;
    ctx.strokeStyle = "#008888";
    ctx.textAlign = "left";
    canvas_arrow(ctx, 10 / scale, W * 2, r.l - r.L / 2 - 1 / scale, W * 2, r.l - r.L / 2);
    canvas_arrow(ctx, 10 / scale, W * 2, r.l - r.L / 2, W * 2, -r.L / 2);
    text("ℓ", W * 2 + 2 / scale, r.l / 2 - r.L / 2)
    canvas_arrow(ctx, 10 / scale, -W / 2 - 20 / scale, (r.L - r.l) * 0.6, -W / 2, (r.L - r.l) * 0.6);
    canvas_arrow(ctx, 10 / scale, W / 2 + 20 / scale, (r.L - r.l) * 0.6, W / 2, (r.L - r.l) * 0.6);
    text("W", W / 2 + 23 / scale, (r.L - r.l) * 0.6)
    canvas_arrow(ctx, 10 / scale, -W * 3, 0, -W * 3, r.L / 2);
    canvas_arrow(ctx, 10 / scale, -W * 3, 0, -W * 3, -r.L / 2);
    ctx.textAlign = "right";
    text("L", -W * 3 - 2 / scale, 0);
    ctx.strokeStyle = "#888888";
    line(0, r.l - r.L / 2, W * 2 + 5 / scale, r.l - r.L / 2);
    line(-W * 3 - 5 / scale, -r.L / 2, W * 2 + 5 / scale, -r.L / 2);
    line(-W * 3 - 5 / scale, r.L / 2, W * 2 + 5 / scale, r.L / 2);
    line(0, -r.L / 2, 0, r.L / 2 + 60 / scale);
    canvas_arrow(ctx, 10 / scale, 0, r.L / 2, 70 / scale * Math.sin(-th), r.L / 2 + 70 / scale * Math.cos(th));
    ctx.beginPath();
    ctx.arc(0, r.L / 2, 40 / scale, Math.PI / 2, Math.PI / 2 + th, th < 0);
    ctx.stroke();
    ctx.textAlign = "center";
    text("θ", 50 / scale * Math.sin(-th / 2), r.L / 2 + 50 / scale * Math.cos(th / 2))

    ctx.beginPath();
    ctx.arc(0, 0, 3 / scale, 0, 2 * Math.PI);
    ctx.fill();
    ctx.textAlign = "left";
    text('center of mass (x,y)', 10 / scale, 0);
    ctx.strokeStyle = "#007bff";
    ctx.lineWidth = 2 / scale;
    canvas_arrow(ctx, 10 / scale, 0, 0, 4 * 40 / scale * Math.sin(th), -4 * 40 / scale * Math.cos(th));
    ctx.textAlign = "right";
    ctx.fillStyle = "#007bff";
    text("mg ", (4 * 40 / scale - 20 / scale) * Math.sin(th), (-4 * 40 / scale + 20 / scale) * Math.cos(th));


    ctx.strokeStyle = "#dc3545";
    ctx.fillStyle = "#dc3545";

    ctx.save();
    ctx.translate(0, -r.L / 2);
    ctx.rotate(th);
    canvas_arrow(ctx, 10 / scale, 0, 0, 4 * 40 / scale / (r.m * r.g) * fx, 0);
    canvas_arrow(ctx, 10 / scale, 0, 0, 0, -4 * 40 / scale / (r.m * r.g) * fy);
    ctx.restore();
    ctx.save();
    ctx.translate(0, -r.L / 2);
    ctx.textAlign = "center";
    ctx.textBaseline = "top";
    text("fx", 4 * 40 / scale / (r.m * r.g) * fx * Math.cos(th), 4 * 40 / scale / (r.m * r.g) * fx * Math.sin(th));
    ctx.textAlign = "right";
    ctx.textBaseline = "middle";
    text("fy", 4 * 40 / scale / (r.m * r.g) * fy * Math.sin(th), (-4 * 40 / scale / (r.m * r.g) * fy - 20 / scale) * Math.cos(th));
    ctx.restore();
}

function resize_info() {
    let wr = document.getElementById('wrap-canvas-info');
    let ch = wr.clientHeight;
    let cw = wr.clientWidth;
    canvasInfo.height = ch * devicePixelRatio;
    canvasInfo.width = cw * devicePixelRatio;
}

function resize_func() {
    height = wrapper.clientHeight;
    width = wrapper.clientWidth;
    canvas.height = height * devicePixelRatio;
    canvas.width = width * devicePixelRatio;
    resize_info();
}

$(window).resize(resize_func);
resize_func();
scale = Math.min(width / (minvx), height / (minvy));

let timeoutId = undefined;


function handleInput() {
    if (typeof timeoutId === 'number') {
        clearTimeout(timeoutId);
    }
    design.params = $('#field-consts').val();
    vlist.forEach((v) => {
        design.controllers[v] = $('#field-K' + v).val();
    });

    timeoutId = setTimeout(() => {
        Object.assign(editorCache.K, updateController(design).K);
    }, 500);
}

function full_screen() {
    $('#left').removeClass('col-6').addClass('d-none');
    $('#right').removeClass('col-6').addClass('col-12');
    $('#btn-full').addClass('d-none');
    $('#btn-normal').removeClass('d-none');
    resize_func();
}

function normal_screen() {
    $('#left').addClass('col-6').removeClass('d-none');
    $('#right').addClass('col-6').removeClass('col-12');
    $('#btn-full').removeClass('d-none');
    $('#btn-normal').addClass('d-none');
    resize_func();
}

$('.tfinput,#field-consts').on("input", handleInput);
handleInput();

function updateMaxAcc() {
    maxAcc = Number($('#field-maxacc').val());
    maxAcc = isNaN(maxAcc) ? 1 : maxAcc;
}
$('#field-maxacc').on("input", updateMaxAcc);
updateMaxAcc();


canvas.onclick = function (e) {
    let rect = e.target.getBoundingClientRect();
    mouseX = e.clientX - Math.floor(rect.left);
    mouseY = e.clientY - Math.floor(rect.top);
    rrx = (mouseX - width / 2) / scale + center.x;
    rry = -(mouseY - height / 2) / scale + center.y;
    rgen = rgen_manual;
}

canvas.ondblclick = function (e) {
    let rect = e.target.getBoundingClientRect();
    mouseX = e.clientX - Math.floor(rect.left);
    mouseY = e.clientY - Math.floor(rect.top);
    rrx = (mouseX - width / 2) / scale + center.x;
    rry = -(mouseY - height / 2) / scale + center.y;
    rx = rrx;
    ry = rry;
    rvx = 0;
    rvy = 0;
    rgen = rgen_manual;
}

canvas.onmousewheel = function (e) {
    if (e.wheelDelta > 0) {
        scale *= 1.1;
    } else {
        scale /= 1.1;
    }
    draw_info();
}

setTimeout(function () {
    window.requestAnimationFrame(loop);
}, 10);